"""
TexCut - Blender Add-on for Creating Optimized 2D Meshes from Images

Copyright (C) 2025 Rupert Rawnsley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.

---

This code was generated by Claude (Anthropic AI) on behalf of the repository owner.

For more information about AI attribution, see ATTRIBUTION.md in the project root.
"""

bl_info = {
    "name": "TexCut",
    "author": "Claude and Rupert",
    "version": (4, 0, 0),
    "blender": (4, 0, 0),
    "location": "Image Editor > Sidebar > Image",
    "description": "Create optimized 2D meshes from images with transparency",
    "category": "Image",
}

import bpy
import bmesh
import numpy as np
import os
from . import texcut_algo


def create_mesh_from_outline(name, outline_points, image_width, image_height):
    """
    Create a mesh from outline points using triangulation.

    Args:
        name: Name for the mesh object
        outline_points: List of (x, y) coordinates (ordered contour)
        image_width: Original image width
        image_height: Original image height

    Returns:
        Created mesh object
    """
    if not outline_points or len(outline_points) < 3:
        return None

    # Create new mesh and object
    mesh = bpy.data.meshes.new(name + "_mesh")
    obj = bpy.data.objects.new(name, mesh)

    # Link object to scene
    bpy.context.collection.objects.link(obj)

    # Create bmesh
    bm = bmesh.new()

    # Add vertices from outline points
    verts = []
    for x, y in outline_points:
        v = bm.verts.new((x, y, 0))
        verts.append(v)

    bm.verts.ensure_lookup_table()

    # Create face from the ordered vertices
    try:
        # The outline points should already be in order from the contour tracing
        # Create as n-gon - Blender will triangulate correctly at render time
        face = bm.faces.new(verts)

    except Exception as e:
        print(f"Face creation failed: {e}")
        # If face creation fails, create a simpler quad as fallback
        bm.clear()
        v1 = bm.verts.new((-0.5, -0.5, 0))
        v2 = bm.verts.new((0.5, -0.5, 0))
        v3 = bm.verts.new((0.5, 0.5, 0))
        v4 = bm.verts.new((-0.5, 0.5, 0))
        bm.faces.new([v1, v2, v3, v4])

    # Update mesh
    bm.to_mesh(mesh)
    bm.free()

    return obj


def create_optimized_mesh(name, image_path, threshold=0.01, boundary_offset=8):
    """
    Main function to create an optimized mesh from an image with transparency.
    Always uses highest quality settings and maintains aspect ratio.

    Args:
        name: Name for the mesh object
        image_path: Path to the image file
        threshold: Alpha threshold for edge detection (0-1)
        boundary_offset: Number of pixels to expand the boundary (default 8)

    Returns:
        Created mesh object
    """
    # Analyze image using OpenCV-free implementation
    outline_points, width, height = texcut_algo.analyze_alpha_channel(image_path, threshold, boundary_offset)

    if not outline_points:
        # Fallback to simple quad if no outline detected
        outline_points = [(-0.5, -0.5), (0.5, -0.5), (0.5, 0.5), (-0.5, 0.5)]

    # Create mesh
    obj = create_mesh_from_outline(name, outline_points, width, height)

    if obj:
        # Scale to maintain aspect ratio
        obj.scale.x = width / max(width, height)
        obj.scale.y = height / max(width, height)

    return obj


def apply_image_texture(obj, image_path):
    """
    Apply the image as a texture to the mesh object.

    Args:
        obj: Mesh object
        image_path: Path to the image file
    """
    # Load image
    img_name = os.path.basename(image_path)

    # Check if image already loaded
    if img_name in bpy.data.images:
        img = bpy.data.images[img_name]
    else:
        img = bpy.data.images.load(image_path)

    apply_image_texture_from_datablock(obj, img)


def apply_image_texture_from_datablock(obj, img):
    """
    Apply a Blender image datablock as a texture to the mesh object.

    Args:
        obj: Mesh object
        img: Blender image datablock
    """
    # Create material
    mat = bpy.data.materials.new(name=obj.name + "_Material")
    mat.use_nodes = True

    # Clear default nodes
    nodes = mat.node_tree.nodes
    nodes.clear()

    # Create nodes
    node_tex = nodes.new('ShaderNodeTexImage')
    node_tex.image = img
    node_tex.location = (0, 0)

    node_bsdf = nodes.new('ShaderNodeBsdfPrincipled')
    node_bsdf.location = (300, 0)

    node_output = nodes.new('ShaderNodeOutputMaterial')
    node_output.location = (600, 0)

    # Link nodes
    links = mat.node_tree.links
    links.new(node_tex.outputs['Color'], node_bsdf.inputs['Base Color'])
    links.new(node_tex.outputs['Alpha'], node_bsdf.inputs['Alpha'])
    links.new(node_bsdf.outputs['BSDF'], node_output.inputs['Surface'])

    # Set blend mode for transparency - handle different Blender versions
    # Blender 4.2+ uses surface_render_method, earlier versions use blend_method
    if bpy.app.version >= (4, 2, 0):
        # Blender 4.2+ - use new EEVEE Next API
        if hasattr(mat, 'surface_render_method'):
            mat.surface_render_method = 'DITHERED'  # Closest to CLIP in new system
    else:
        # Blender 4.0-4.1 - use legacy API
        mat.blend_method = 'CLIP'  # Use alpha clipping (MASK mode)
        if hasattr(mat, 'shadow_method'):  # shadow_method removed in 4.3
            mat.shadow_method = 'CLIP'

    # Assign material to object
    if obj.data.materials:
        obj.data.materials[0] = mat
    else:
        obj.data.materials.append(mat)

    # Create UV map manually - vertices are already in -0.5 to 0.5 range
    # We just need to shift them to 0-1 range for UVs
    if not obj.data.uv_layers:
        obj.data.uv_layers.new(name="UVMap")

    uv_layer = obj.data.uv_layers.active.data

    for poly in obj.data.polygons:
        for loop_index in poly.loop_indices:
            loop = obj.data.loops[loop_index]
            vert = obj.data.vertices[loop.vertex_index]

            # Convert from -0.5..0.5 mesh coordinates to 0..1 UV coordinates
            u = vert.co.x + 0.5
            v = vert.co.y + 0.5

            uv_layer[loop_index].uv = (u, v)


class TEXCUT_OT_create_mesh(bpy.types.Operator):
    """Create optimized mesh from the current image"""
    bl_idname = "texcut.create_mesh"
    bl_label = "Create Mesh from Image"
    bl_options = {'REGISTER', 'UNDO'}

    alpha_threshold: bpy.props.FloatProperty(
        name="Alpha Threshold",
        description="Alpha threshold for edge detection (higher = tighter fit around opaque areas)",
        default=0.01,
        min=0.01,
        max=1.0,
        step=0.05
    )

    boundary_offset: bpy.props.IntProperty(
        name="Boundary Offset",
        description="Number of pixels to expand the boundary to avoid edge clipping (minimum 1 to prevent self-intersections)",
        default=8,
        min=1,
        max=20
    )

    @classmethod
    def poll(cls, context):
        """Only enable if an image is active in the Image Editor."""
        return (context.space_data.type == 'IMAGE_EDITOR' and
                context.space_data.image is not None)

    def invoke(self, context, event):
        """Show dialog with settings before executing."""
        return context.window_manager.invoke_props_dialog(self)

    def execute(self, context):
        import tempfile

        image = context.space_data.image

        if not image:
            self.report({'ERROR'}, "No image selected")
            return {'CANCELLED'}

        # Check if image has a filepath and the file exists
        if image.filepath:
            filepath = bpy.path.abspath(image.filepath)
            # If the file doesn't exist, treat it as packed/generated
            if not os.path.exists(filepath):
                filepath = None
        else:
            filepath = None

        # If no valid filepath, save image to temp file
        if filepath is None:
            # Image is packed, generated, or file missing - save to temp file
            temp_dir = tempfile.gettempdir()
            filepath = os.path.join(temp_dir, f"{image.name}.png")

            # Save image to temp location
            original_filepath = image.filepath_raw
            original_file_format = image.file_format

            image.filepath_raw = filepath
            image.file_format = 'PNG'
            image.save()

            # Restore original settings
            image.filepath_raw = original_filepath
            image.file_format = original_file_format

        try:
            # Always use highest quality
            obj = create_optimized_mesh(
                image.name,
                filepath,
                self.alpha_threshold,
                self.boundary_offset
            )

            if obj:
                # Apply texture using the Blender image datablock
                apply_image_texture_from_datablock(obj, image)

                # Switch to 3D viewport and select the new object
                # Find a 3D viewport
                for area in context.screen.areas:
                    if area.type == 'VIEW_3D':
                        for space in area.spaces:
                            if space.type == 'VIEW_3D':
                                # Set the object as active
                                context.view_layer.objects.active = obj
                                obj.select_set(True)
                                break
                        break

                self.report({'INFO'}, f"Created mesh: {obj.name}")
                return {'FINISHED'}
            else:
                self.report({'ERROR'}, "Failed to create mesh")
                return {'CANCELLED'}

        except Exception as e:
            self.report({'ERROR'}, f"Error: {str(e)}")
            import traceback
            traceback.print_exc()
            return {'CANCELLED'}

    def draw(self, context):
        """Draw the operator properties."""
        layout = self.layout

        layout.prop(self, "alpha_threshold")
        layout.prop(self, "boundary_offset")


class TEXCUT_PT_panel(bpy.types.Panel):
    """TexCut panel in the Image Editor sidebar"""
    bl_label = "TexCut"
    bl_idname = "TEXCUT_PT_panel"
    bl_space_type = 'IMAGE_EDITOR'
    bl_region_type = 'UI'
    bl_category = 'Image'

    @classmethod
    def poll(cls, context):
        """Only show panel when an image is loaded."""
        return context.space_data.image is not None

    def draw(self, context):
        layout = self.layout
        layout.operator("texcut.create_mesh", icon='MESH_DATA')

# Registration
classes = (
    TEXCUT_OT_create_mesh,
    TEXCUT_PT_panel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()

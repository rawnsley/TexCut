"""
TexCut - Blender Add-on for Creating Optimized 2D Meshes from Images

This code was generated by Claude (Anthropic AI) on behalf of the repository owner.

For more information about AI attribution, see ATTRIBUTION.md in the project root.
"""

bl_info = {
    "name": "TexCut",
    "author": "Your Name",
    "version": (2, 1, 0),
    "blender": (3, 0, 0),
    "location": "Image Editor > Sidebar > Image",
    "description": "Create optimized 2D meshes from images with transparency",
    "category": "Image",
}

import bpy
import bmesh
import numpy as np
from PIL import Image
import cv2
import os


def fix_self_intersections(contour):
    """
    Fix self-intersecting polygons using Shapely's buffer(0) method.
    Requires Shapely to be installed.

    Args:
        contour: OpenCV contour array

    Returns:
        Fixed contour array (OpenCV format)

    Raises:
        ImportError: If Shapely is not available
    """
    try:
        from shapely.geometry import Polygon
    except ImportError:
        raise ImportError(
            "Shapely is required for HIGH quality mesh generation. "
            "Please install it using: pip install shapely"
        )

    # Convert to list of tuples
    contour_list = [(int(point[0][0]), int(point[0][1])) for point in contour]

    # Create polygon
    poly = Polygon(contour_list)

    # Fix self-intersections using buffer(0) - a well-known technique
    fixed_poly = poly.buffer(0)

    # If it becomes MultiPolygon, take the largest part
    if fixed_poly.geom_type == 'MultiPolygon':
        fixed_poly = max(fixed_poly.geoms, key=lambda p: p.area)

    # Extract exterior coordinates (excluding duplicate last point)
    coords = list(fixed_poly.exterior.coords[:-1])

    # Convert back to OpenCV format
    coords_array = np.array(coords, dtype=np.int32).reshape((-1, 1, 2))

    print(f"TexCut: Fixed self-intersections using Shapely ({len(coords)} vertices)")
    return coords_array


def analyze_alpha_channel(image_path, threshold=0.01):
    """
    Analyze image alpha channel and return outline points using OpenCV contour detection.
    Always uses highest quality (0.001) with self-intersection fixing.
    Requires Shapely for geometry repair.

    Args:
        image_path: Path to the image file
        threshold: Alpha threshold for considering a pixel opaque (0-1)

    Returns:
        Tuple of (normalized_contour, width, height)

    Raises:
        ImportError: If Shapely is not installed
    """
    img = Image.open(image_path).convert('RGBA')
    width, height = img.size

    # Get alpha channel as numpy array
    alpha = np.array(img)[:, :, 3]

    # Create binary mask (0 or 255 for OpenCV)
    mask = (alpha > (threshold * 255)).astype(np.uint8) * 255

    # Find contours using OpenCV
    contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    print(f"TexCut: Found {len(contours)} contours with threshold={threshold}")

    if len(contours) == 0:
        # No contours found, return empty
        print(f"TexCut: No contours found!")
        return [], width, height

    # Get the largest contour (main object)
    largest_contour = max(contours, key=cv2.contourArea)
    area = cv2.contourArea(largest_contour)
    print(f"TexCut: Largest contour area = {area:.0f} pixels, {len(largest_contour)} initial points")

    # Use highest quality simplification (0.001)
    perimeter = cv2.arcLength(largest_contour, True)
    epsilon = 0.001 * perimeter
    largest_contour = cv2.approxPolyDP(largest_contour, epsilon, True)
    print(f"TexCut: After simplification (epsilon={epsilon:.2f}): {len(largest_contour)} points")

    # Fix any self-intersections using Shapely
    largest_contour = fix_self_intersections(largest_contour)
    print(f"TexCut: After self-intersection fix: {len(largest_contour)} points")

    # Convert to list of tuples
    contour = [(int(point[0][0]), int(point[0][1])) for point in largest_contour]

    # Normalize coordinates to -0.5 to 0.5 range
    normalized_contour = []
    for x, y in contour:
        norm_x = (x / width) - 0.5
        norm_y = 0.5 - (y / height)  # Flip Y axis for Blender
        normalized_contour.append((norm_x, norm_y))

    return normalized_contour, width, height


def create_mesh_from_outline(name, outline_points, image_width, image_height):
    """
    Create a mesh from outline points using triangulation.

    Args:
        name: Name for the mesh object
        outline_points: List of (x, y) coordinates (ordered contour)
        image_width: Original image width
        image_height: Original image height

    Returns:
        Created mesh object
    """
    if not outline_points or len(outline_points) < 3:
        return None

    # Create new mesh and object
    mesh = bpy.data.meshes.new(name + "_mesh")
    obj = bpy.data.objects.new(name, mesh)

    # Link object to scene
    bpy.context.collection.objects.link(obj)

    # Create bmesh
    bm = bmesh.new()

    # Add vertices from outline points
    verts = []
    for x, y in outline_points:
        v = bm.verts.new((x, y, 0))
        verts.append(v)

    bm.verts.ensure_lookup_table()

    # Create face from the ordered vertices
    try:
        # The outline points should already be in order from the contour tracing
        # Create as n-gon - Blender will triangulate correctly at render time
        face = bm.faces.new(verts)

    except Exception as e:
        print(f"Face creation failed: {e}")
        # If face creation fails, create a simpler quad as fallback
        bm.clear()
        v1 = bm.verts.new((-0.5, -0.5, 0))
        v2 = bm.verts.new((0.5, -0.5, 0))
        v3 = bm.verts.new((0.5, 0.5, 0))
        v4 = bm.verts.new((-0.5, 0.5, 0))
        bm.faces.new([v1, v2, v3, v4])

    # Update mesh
    bm.to_mesh(mesh)
    bm.free()

    return obj


def create_optimized_mesh(name, image_path, aspect_ratio=True, threshold=0.01):
    """
    Main function to create an optimized mesh from an image with transparency.
    Always uses highest quality settings.

    Args:
        name: Name for the mesh object
        image_path: Path to the image file
        aspect_ratio: Maintain image aspect ratio
        threshold: Alpha threshold for edge detection (0-1)

    Returns:
        Created mesh object
    """
    # Analyze image
    outline_points, width, height = analyze_alpha_channel(image_path, threshold)

    if not outline_points:
        # Fallback to simple quad if no outline detected
        outline_points = [(-0.5, -0.5), (0.5, -0.5), (0.5, 0.5), (-0.5, 0.5)]

    # Create mesh
    obj = create_mesh_from_outline(name, outline_points, width, height)

    if obj and aspect_ratio:
        # Scale to maintain aspect ratio
        obj.scale.x = width / max(width, height)
        obj.scale.y = height / max(width, height)

    return obj


def apply_image_texture(obj, image_path):
    """
    Apply the image as a texture to the mesh object.

    Args:
        obj: Mesh object
        image_path: Path to the image file
    """
    # Load image
    img_name = os.path.basename(image_path)

    # Check if image already loaded
    if img_name in bpy.data.images:
        img = bpy.data.images[img_name]
    else:
        img = bpy.data.images.load(image_path)

    apply_image_texture_from_datablock(obj, img)


def apply_image_texture_from_datablock(obj, img):
    """
    Apply a Blender image datablock as a texture to the mesh object.

    Args:
        obj: Mesh object
        img: Blender image datablock
    """
    # Create material
    mat = bpy.data.materials.new(name=obj.name + "_Material")
    mat.use_nodes = True

    # Clear default nodes
    nodes = mat.node_tree.nodes
    nodes.clear()

    # Create nodes
    node_tex = nodes.new('ShaderNodeTexImage')
    node_tex.image = img
    node_tex.location = (0, 0)

    node_bsdf = nodes.new('ShaderNodeBsdfPrincipled')
    node_bsdf.location = (300, 0)

    node_output = nodes.new('ShaderNodeOutputMaterial')
    node_output.location = (600, 0)

    # Link nodes
    links = mat.node_tree.links
    links.new(node_tex.outputs['Color'], node_bsdf.inputs['Base Color'])
    links.new(node_tex.outputs['Alpha'], node_bsdf.inputs['Alpha'])
    links.new(node_bsdf.outputs['BSDF'], node_output.inputs['Surface'])

    # Set blend mode for transparency
    mat.blend_method = 'CLIP'  # Use alpha clipping (MASK mode)
    mat.shadow_method = 'CLIP'

    # Assign material to object
    if obj.data.materials:
        obj.data.materials[0] = mat
    else:
        obj.data.materials.append(mat)

    # Create UV map manually - vertices are already in -0.5 to 0.5 range
    # We just need to shift them to 0-1 range for UVs
    if not obj.data.uv_layers:
        obj.data.uv_layers.new(name="UVMap")

    uv_layer = obj.data.uv_layers.active.data

    for poly in obj.data.polygons:
        for loop_index in poly.loop_indices:
            loop = obj.data.loops[loop_index]
            vert = obj.data.vertices[loop.vertex_index]

            # Convert from -0.5..0.5 mesh coordinates to 0..1 UV coordinates
            u = vert.co.x + 0.5
            v = vert.co.y + 0.5

            uv_layer[loop_index].uv = (u, v)


class TEXCUT_OT_create_mesh(bpy.types.Operator):
    """Create optimized mesh from the current image"""
    bl_idname = "texcut.create_mesh"
    bl_label = "Create Mesh from Image"
    bl_options = {'REGISTER', 'UNDO'}

    maintain_aspect: bpy.props.BoolProperty(
        name="Maintain Aspect Ratio",
        description="Scale mesh to maintain image aspect ratio",
        default=True
    )

    alpha_threshold: bpy.props.FloatProperty(
        name="Alpha Threshold",
        description="Alpha threshold for edge detection (higher = tighter fit around opaque areas)",
        default=0.01,
        min=0.01,
        max=1.0,
        step=0.05
    )

    @classmethod
    def poll(cls, context):
        """Only enable if an image is active in the Image Editor."""
        return (context.space_data.type == 'IMAGE_EDITOR' and
                context.space_data.image is not None)

    def invoke(self, context, event):
        """Show dialog with settings before executing."""
        return context.window_manager.invoke_props_dialog(self)

    def execute(self, context):
        import tempfile

        image = context.space_data.image

        if not image:
            self.report({'ERROR'}, "No image selected")
            return {'CANCELLED'}

        # Check if image has a filepath and the file exists
        if image.filepath:
            filepath = bpy.path.abspath(image.filepath)
            # If the file doesn't exist, treat it as packed/generated
            if not os.path.exists(filepath):
                filepath = None
        else:
            filepath = None

        # If no valid filepath, save image to temp file
        if filepath is None:
            # Image is packed, generated, or file missing - save to temp file
            temp_dir = tempfile.gettempdir()
            filepath = os.path.join(temp_dir, f"{image.name}.png")

            # Save image to temp location
            original_filepath = image.filepath_raw
            original_file_format = image.file_format

            image.filepath_raw = filepath
            image.file_format = 'PNG'
            image.save()

            # Restore original settings
            image.filepath_raw = original_filepath
            image.file_format = original_file_format

        try:
            # Always use highest quality
            obj = create_optimized_mesh(
                image.name,
                filepath,
                self.maintain_aspect,
                self.alpha_threshold
            )

            if obj:
                # Apply texture using the Blender image datablock
                apply_image_texture_from_datablock(obj, image)

                # Switch to 3D viewport and select the new object
                # Find a 3D viewport
                for area in context.screen.areas:
                    if area.type == 'VIEW_3D':
                        for space in area.spaces:
                            if space.type == 'VIEW_3D':
                                # Set the object as active
                                context.view_layer.objects.active = obj
                                obj.select_set(True)
                                break
                        break

                self.report({'INFO'}, f"Created mesh: {obj.name}")
                return {'FINISHED'}
            else:
                self.report({'ERROR'}, "Failed to create mesh")
                return {'CANCELLED'}

        except Exception as e:
            self.report({'ERROR'}, f"Error: {str(e)}")
            import traceback
            traceback.print_exc()
            return {'CANCELLED'}

    def draw(self, context):
        """Draw the operator properties."""
        layout = self.layout

        layout.prop(self, "alpha_threshold")
        layout.prop(self, "maintain_aspect")


class TEXCUT_PT_panel(bpy.types.Panel):
    """TexCut panel in the Image Editor sidebar"""
    bl_label = "TexCut"
    bl_idname = "TEXCUT_PT_panel"
    bl_space_type = 'IMAGE_EDITOR'
    bl_region_type = 'UI'
    bl_category = 'Image'

    @classmethod
    def poll(cls, context):
        """Only show panel when an image is loaded."""
        return context.space_data.image is not None

    def draw(self, context):
        layout = self.layout

        image = context.space_data.image

        if image:
            layout.label(text=f"Image: {image.name}")
            layout.separator()

        layout.label(text="Create Optimized Mesh:")
        layout.operator("texcut.create_mesh", icon='MESH_DATA')

        layout.separator()
        layout.label(text="Highest quality, ~160 vertices", icon='INFO')
        layout.label(text="Requires Shapely installed")


# Registration
classes = (
    TEXCUT_OT_create_mesh,
    TEXCUT_PT_panel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()

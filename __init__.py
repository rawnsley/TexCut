"""
TexCut - Blender Add-on for Creating Optimized 2D Meshes from Images

This code was generated by Claude (Anthropic AI) on behalf of the repository owner.

For more information about AI attribution, see ATTRIBUTION.md in the project root.
"""

bl_info = {
    "name": "TexCut",
    "author": "Your Name",
    "version": (1, 0, 0),
    "blender": (3, 0, 0),
    "location": "Image Editor > Sidebar > Image",
    "description": "Create optimized 2D meshes from images with transparency",
    "category": "Image",
}

import bpy
import bmesh
import numpy as np
from PIL import Image
import cv2
import os


def analyze_alpha_channel(image_path, threshold=0.5, simplify_tolerance=2.0):
    """
    Analyze image alpha channel and return outline points using OpenCV contour detection.

    Args:
        image_path: Path to the image file
        threshold: Alpha threshold for considering a pixel opaque (0-1)
        simplify_tolerance: Tolerance for contour simplification (higher = simpler)

    Returns:
        List of (x, y) coordinates representing the outline
    """
    img = Image.open(image_path).convert('RGBA')
    width, height = img.size

    # Get alpha channel as numpy array
    alpha = np.array(img)[:, :, 3]

    # Create binary mask (0 or 255 for OpenCV)
    mask = (alpha > (threshold * 255)).astype(np.uint8) * 255

    # Find contours using OpenCV
    contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    print(f"TexCut: Found {len(contours)} contours with threshold={threshold}")

    if len(contours) == 0:
        # No contours found, return empty
        print(f"TexCut: No contours found!")
        return [], width, height

    # Get the largest contour (main object)
    largest_contour = max(contours, key=cv2.contourArea)
    area = cv2.contourArea(largest_contour)
    print(f"TexCut: Largest contour area = {area:.0f} pixels, {len(largest_contour)} points")

    # Apply additional simplification if needed
    if simplify_tolerance > 0:
        epsilon = simplify_tolerance
        largest_contour = cv2.approxPolyDP(largest_contour, epsilon, True)
        print(f"TexCut: After simplification (epsilon={epsilon}): {len(largest_contour)} points")

    # Convert OpenCV contour format to list of tuples
    contour = []
    for point in largest_contour:
        x, y = point[0]
        contour.append((int(x), int(y)))

    # Normalize coordinates to -0.5 to 0.5 range
    normalized_contour = []
    for x, y in contour:
        norm_x = (x / width) - 0.5
        norm_y = 0.5 - (y / height)  # Flip Y axis for Blender
        normalized_contour.append((norm_x, norm_y))

    return normalized_contour, width, height


def create_mesh_from_outline(name, outline_points, image_width, image_height):
    """
    Create a mesh from outline points using triangulation.

    Args:
        name: Name for the mesh object
        outline_points: List of (x, y) coordinates (ordered contour)
        image_width: Original image width
        image_height: Original image height

    Returns:
        Created mesh object
    """
    if not outline_points or len(outline_points) < 3:
        return None

    # Create new mesh and object
    mesh = bpy.data.meshes.new(name + "_mesh")
    obj = bpy.data.objects.new(name, mesh)

    # Link object to scene
    bpy.context.collection.objects.link(obj)

    # Create bmesh
    bm = bmesh.new()

    # Add vertices from outline points
    verts = []
    for x, y in outline_points:
        v = bm.verts.new((x, y, 0))
        verts.append(v)

    bm.verts.ensure_lookup_table()

    # Create face from the ordered vertices
    try:
        # The outline points should already be in order from the contour tracing
        face = bm.faces.new(verts)

        # Triangulate the face for better rendering
        bmesh.ops.triangulate(bm, faces=[face])

    except Exception as e:
        print(f"Face creation failed: {e}")
        # If face creation fails, create a simpler quad as fallback
        bm.clear()
        v1 = bm.verts.new((-0.5, -0.5, 0))
        v2 = bm.verts.new((0.5, -0.5, 0))
        v3 = bm.verts.new((0.5, 0.5, 0))
        v4 = bm.verts.new((-0.5, 0.5, 0))
        bm.faces.new([v1, v2, v3, v4])

    # Update mesh
    bm.to_mesh(mesh)
    bm.free()

    return obj


def create_optimized_mesh(name, image_path, aspect_ratio=True, threshold=0.5, simplify_tolerance=2.0):
    """
    Main function to create an optimized mesh from an image with transparency.

    Args:
        name: Name for the mesh object
        image_path: Path to the image file
        aspect_ratio: Maintain image aspect ratio
        threshold: Alpha threshold for edge detection (0-1)
        simplify_tolerance: Tolerance for contour simplification

    Returns:
        Created mesh object
    """
    # Analyze image
    outline_points, width, height = analyze_alpha_channel(image_path, threshold, simplify_tolerance)

    if not outline_points:
        # Fallback to simple quad if no outline detected
        outline_points = [(-0.5, -0.5), (0.5, -0.5), (0.5, 0.5), (-0.5, 0.5)]

    # Create mesh
    obj = create_mesh_from_outline(name, outline_points, width, height)

    if obj and aspect_ratio:
        # Scale to maintain aspect ratio
        obj.scale.x = width / max(width, height)
        obj.scale.y = height / max(width, height)

    return obj


def apply_image_texture(obj, image_path):
    """
    Apply the image as a texture to the mesh object.

    Args:
        obj: Mesh object
        image_path: Path to the image file
    """
    # Load image
    img_name = os.path.basename(image_path)

    # Check if image already loaded
    if img_name in bpy.data.images:
        img = bpy.data.images[img_name]
    else:
        img = bpy.data.images.load(image_path)

    apply_image_texture_from_datablock(obj, img)


def apply_image_texture_from_datablock(obj, img):
    """
    Apply a Blender image datablock as a texture to the mesh object.

    Args:
        obj: Mesh object
        img: Blender image datablock
    """
    # Create material
    mat = bpy.data.materials.new(name=obj.name + "_Material")
    mat.use_nodes = True

    # Clear default nodes
    nodes = mat.node_tree.nodes
    nodes.clear()

    # Create nodes
    node_tex = nodes.new('ShaderNodeTexImage')
    node_tex.image = img
    node_tex.location = (0, 0)

    node_bsdf = nodes.new('ShaderNodeBsdfPrincipled')
    node_bsdf.location = (300, 0)

    node_output = nodes.new('ShaderNodeOutputMaterial')
    node_output.location = (600, 0)

    # Link nodes
    links = mat.node_tree.links
    links.new(node_tex.outputs['Color'], node_bsdf.inputs['Base Color'])
    links.new(node_tex.outputs['Alpha'], node_bsdf.inputs['Alpha'])
    links.new(node_bsdf.outputs['BSDF'], node_output.inputs['Surface'])

    # Set blend mode for transparency
    mat.blend_method = 'BLEND'
    mat.shadow_method = 'CLIP'

    # Assign material to object
    if obj.data.materials:
        obj.data.materials[0] = mat
    else:
        obj.data.materials.append(mat)

    # Create UV map manually - vertices are already in -0.5 to 0.5 range
    # We just need to shift them to 0-1 range for UVs
    if not obj.data.uv_layers:
        obj.data.uv_layers.new(name="UVMap")

    uv_layer = obj.data.uv_layers.active.data

    for poly in obj.data.polygons:
        for loop_index in poly.loop_indices:
            loop = obj.data.loops[loop_index]
            vert = obj.data.vertices[loop.vertex_index]

            # Convert from -0.5..0.5 mesh coordinates to 0..1 UV coordinates
            u = vert.co.x + 0.5
            v = vert.co.y + 0.5

            uv_layer[loop_index].uv = (u, v)


class TEXCUT_OT_create_mesh(bpy.types.Operator):
    """Create optimized mesh from the current image"""
    bl_idname = "texcut.create_mesh"
    bl_label = "Create Mesh from Image"
    bl_options = {'REGISTER', 'UNDO'}

    maintain_aspect: bpy.props.BoolProperty(
        name="Maintain Aspect Ratio",
        description="Scale mesh to maintain image aspect ratio",
        default=True
    )

    alpha_threshold: bpy.props.FloatProperty(
        name="Alpha Threshold",
        description="Alpha threshold for edge detection (higher = tighter fit around opaque areas)",
        default=0.5,
        min=0.01,
        max=1.0,
        step=0.05
    )

    simplify_tolerance: bpy.props.FloatProperty(
        name="Simplification",
        description="Mesh simplification tolerance (higher = fewer vertices)",
        default=2.0,
        min=0.5,
        max=10.0,
        step=0.5
    )

    @classmethod
    def poll(cls, context):
        """Only enable if an image is active in the Image Editor."""
        return (context.space_data.type == 'IMAGE_EDITOR' and
                context.space_data.image is not None)

    def execute(self, context):
        import tempfile

        image = context.space_data.image

        if not image:
            self.report({'ERROR'}, "No image selected")
            return {'CANCELLED'}

        # Check if image has a filepath
        if image.filepath:
            # Use the existing filepath
            filepath = bpy.path.abspath(image.filepath)
        else:
            # Image is packed or generated, save to temp file
            temp_dir = tempfile.gettempdir()
            filepath = os.path.join(temp_dir, f"{image.name}.png")

            # Save image to temp location
            original_filepath = image.filepath_raw
            original_file_format = image.file_format

            image.filepath_raw = filepath
            image.file_format = 'PNG'
            image.save()

            # Restore original settings
            image.filepath_raw = original_filepath
            image.file_format = original_file_format

        try:
            obj = create_optimized_mesh(
                image.name,
                filepath,
                self.maintain_aspect,
                self.alpha_threshold,
                self.simplify_tolerance
            )

            if obj:
                # Apply texture using the Blender image datablock
                apply_image_texture_from_datablock(obj, image)

                # Switch to 3D viewport and select the new object
                # Find a 3D viewport
                for area in context.screen.areas:
                    if area.type == 'VIEW_3D':
                        for space in area.spaces:
                            if space.type == 'VIEW_3D':
                                # Set the object as active
                                context.view_layer.objects.active = obj
                                obj.select_set(True)
                                break
                        break

                self.report({'INFO'}, f"Created mesh: {obj.name}")
                return {'FINISHED'}
            else:
                self.report({'ERROR'}, "Failed to create mesh")
                return {'CANCELLED'}

        except Exception as e:
            self.report({'ERROR'}, f"Error: {str(e)}")
            import traceback
            traceback.print_exc()
            return {'CANCELLED'}

    def draw(self, context):
        """Draw the operator properties."""
        layout = self.layout

        layout.prop(self, "alpha_threshold")
        layout.prop(self, "simplify_tolerance")
        layout.prop(self, "maintain_aspect")


class TEXCUT_PT_panel(bpy.types.Panel):
    """TexCut panel in the Image Editor sidebar"""
    bl_label = "TexCut"
    bl_idname = "TEXCUT_PT_panel"
    bl_space_type = 'IMAGE_EDITOR'
    bl_region_type = 'UI'
    bl_category = 'Image'

    @classmethod
    def poll(cls, context):
        """Only show panel when an image is loaded."""
        return context.space_data.image is not None

    def draw(self, context):
        layout = self.layout

        image = context.space_data.image

        if image:
            layout.label(text=f"Image: {image.name}")
            layout.separator()

        layout.label(text="Create Optimized Mesh:")
        layout.operator("texcut.create_mesh", icon='MESH_DATA')

        layout.separator()
        layout.label(text="Reduces pixel overdraw by", icon='INFO')
        layout.label(text="following transparency outline")


# Registration
classes = (
    TEXCUT_OT_create_mesh,
    TEXCUT_PT_panel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()

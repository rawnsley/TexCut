"""
TexCut - Blender Add-on for Creating Optimized 2D Meshes from Images

This code was generated by Claude (Anthropic AI) on behalf of the repository owner.

For more information about AI attribution, see ATTRIBUTION.md in the project root.
"""

bl_info = {
    "name": "TexCut",
    "author": "Your Name",
    "version": (1, 0, 0),
    "blender": (3, 0, 0),
    "location": "View3D > Sidebar > TexCut",
    "description": "Create optimized 2D meshes from images with transparency",
    "category": "Mesh",
}

import bpy
import bmesh
from mathutils import Vector
import numpy as np
from PIL import Image
import cv2
import os


def analyze_alpha_channel(image_path, threshold=0.5, simplify_tolerance=2.0):
    """
    Analyze image alpha channel and return outline points using OpenCV contour detection.

    Args:
        image_path: Path to the image file
        threshold: Alpha threshold for considering a pixel opaque (0-1)
        simplify_tolerance: Tolerance for contour simplification (higher = simpler)

    Returns:
        List of (x, y) coordinates representing the outline
    """
    img = Image.open(image_path).convert('RGBA')
    width, height = img.size

    # Get alpha channel as numpy array
    alpha = np.array(img)[:, :, 3]

    # Create binary mask (0 or 255 for OpenCV)
    mask = (alpha > (threshold * 255)).astype(np.uint8) * 255

    # Find contours using OpenCV
    contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    print(f"TexCut: Found {len(contours)} contours with threshold={threshold}")

    if len(contours) == 0:
        # No contours found, return empty
        print(f"TexCut: No contours found!")
        return [], width, height

    # Get the largest contour (main object)
    largest_contour = max(contours, key=cv2.contourArea)
    area = cv2.contourArea(largest_contour)
    print(f"TexCut: Largest contour area = {area:.0f} pixels, {len(largest_contour)} points")

    # Apply additional simplification if needed
    if simplify_tolerance > 0:
        epsilon = simplify_tolerance
        largest_contour = cv2.approxPolyDP(largest_contour, epsilon, True)
        print(f"TexCut: After simplification (epsilon={epsilon}): {len(largest_contour)} points")

    # Convert OpenCV contour format to list of tuples
    contour = []
    for point in largest_contour:
        x, y = point[0]
        contour.append((int(x), int(y)))

    # Normalize coordinates to -0.5 to 0.5 range
    normalized_contour = []
    for x, y in contour:
        norm_x = (x / width) - 0.5
        norm_y = 0.5 - (y / height)  # Flip Y axis for Blender
        normalized_contour.append((norm_x, norm_y))

    return normalized_contour, width, height


def create_mesh_from_outline(name, outline_points, image_width, image_height):
    """
    Create a mesh from outline points using triangulation.

    Args:
        name: Name for the mesh object
        outline_points: List of (x, y) coordinates (ordered contour)
        image_width: Original image width
        image_height: Original image height

    Returns:
        Created mesh object
    """
    if not outline_points or len(outline_points) < 3:
        return None

    # Create new mesh and object
    mesh = bpy.data.meshes.new(name + "_mesh")
    obj = bpy.data.objects.new(name, mesh)

    # Link object to scene
    bpy.context.collection.objects.link(obj)

    # Create bmesh
    bm = bmesh.new()

    # Add vertices from outline points
    verts = []
    for x, y in outline_points:
        v = bm.verts.new((x, y, 0))
        verts.append(v)

    bm.verts.ensure_lookup_table()

    # Create face from the ordered vertices
    try:
        # The outline points should already be in order from the contour tracing
        face = bm.faces.new(verts)

        # Triangulate the face for better rendering
        bmesh.ops.triangulate(bm, faces=[face])

    except Exception as e:
        print(f"Face creation failed: {e}")
        # If face creation fails, create a simpler quad as fallback
        bm.clear()
        v1 = bm.verts.new((-0.5, -0.5, 0))
        v2 = bm.verts.new((0.5, -0.5, 0))
        v3 = bm.verts.new((0.5, 0.5, 0))
        v4 = bm.verts.new((-0.5, 0.5, 0))
        bm.faces.new([v1, v2, v3, v4])

    # Update mesh
    bm.to_mesh(mesh)
    bm.free()

    return obj


def create_optimized_mesh(name, image_path, aspect_ratio=True, threshold=0.5, simplify_tolerance=2.0):
    """
    Main function to create an optimized mesh from an image with transparency.

    Args:
        name: Name for the mesh object
        image_path: Path to the image file
        aspect_ratio: Maintain image aspect ratio
        threshold: Alpha threshold for edge detection (0-1)
        simplify_tolerance: Tolerance for contour simplification

    Returns:
        Created mesh object
    """
    # Analyze image
    outline_points, width, height = analyze_alpha_channel(image_path, threshold, simplify_tolerance)

    if not outline_points:
        # Fallback to simple quad if no outline detected
        outline_points = [(-0.5, -0.5), (0.5, -0.5), (0.5, 0.5), (-0.5, 0.5)]

    # Create mesh
    obj = create_mesh_from_outline(name, outline_points, width, height)

    if obj and aspect_ratio:
        # Scale to maintain aspect ratio
        obj.scale.x = width / max(width, height)
        obj.scale.y = height / max(width, height)

    return obj


def apply_image_texture(obj, image_path):
    """
    Apply the image as a texture to the mesh object.

    Args:
        obj: Mesh object
        image_path: Path to the image file
    """
    # Load image
    img_name = os.path.basename(image_path)

    # Check if image already loaded
    if img_name in bpy.data.images:
        img = bpy.data.images[img_name]
    else:
        img = bpy.data.images.load(image_path)

    # Create material
    mat = bpy.data.materials.new(name=obj.name + "_Material")
    mat.use_nodes = True

    # Clear default nodes
    nodes = mat.node_tree.nodes
    nodes.clear()

    # Create nodes
    node_tex = nodes.new('ShaderNodeTexImage')
    node_tex.image = img
    node_tex.location = (0, 0)

    node_bsdf = nodes.new('ShaderNodeBsdfPrincipled')
    node_bsdf.location = (300, 0)

    node_output = nodes.new('ShaderNodeOutputMaterial')
    node_output.location = (600, 0)

    # Link nodes
    links = mat.node_tree.links
    links.new(node_tex.outputs['Color'], node_bsdf.inputs['Base Color'])
    links.new(node_tex.outputs['Alpha'], node_bsdf.inputs['Alpha'])
    links.new(node_bsdf.outputs['BSDF'], node_output.inputs['Surface'])

    # Set blend mode for transparency
    mat.blend_method = 'BLEND'
    mat.shadow_method = 'CLIP'

    # Assign material to object
    if obj.data.materials:
        obj.data.materials[0] = mat
    else:
        obj.data.materials.append(mat)

    # Create UV map manually - vertices are already in -0.5 to 0.5 range
    # We just need to shift them to 0-1 range for UVs
    if not obj.data.uv_layers:
        obj.data.uv_layers.new(name="UVMap")

    uv_layer = obj.data.uv_layers.active.data

    for poly in obj.data.polygons:
        for loop_index in poly.loop_indices:
            loop = obj.data.loops[loop_index]
            vert = obj.data.vertices[loop.vertex_index]

            # Convert from -0.5..0.5 mesh coordinates to 0..1 UV coordinates
            u = vert.co.x + 0.5
            v = vert.co.y + 0.5

            uv_layer[loop_index].uv = (u, v)


class TEXCUT_OT_create_mesh(bpy.types.Operator):
    """Create optimized mesh from image with transparency"""
    bl_idname = "texcut.create_mesh"
    bl_label = "Create Mesh from Image"
    bl_options = {'REGISTER', 'UNDO'}

    filepath: bpy.props.StringProperty(
        name="Image File",
        description="Path to image file with transparency",
        subtype='FILE_PATH'
    )

    maintain_aspect: bpy.props.BoolProperty(
        name="Maintain Aspect Ratio",
        description="Scale mesh to maintain image aspect ratio",
        default=True
    )

    alpha_threshold: bpy.props.FloatProperty(
        name="Alpha Threshold",
        description="Alpha threshold for edge detection (higher = tighter fit around opaque areas)",
        default=0.5,
        min=0.01,
        max=1.0,
        step=0.05
    )

    simplify_tolerance: bpy.props.FloatProperty(
        name="Simplification",
        description="Mesh simplification tolerance (higher = fewer vertices)",
        default=2.0,
        min=0.5,
        max=10.0,
        step=0.5
    )

    def execute(self, context):
        if not self.filepath or not os.path.exists(self.filepath):
            self.report({'ERROR'}, "Invalid image file path")
            return {'CANCELLED'}

        # Create mesh
        obj_name = os.path.splitext(os.path.basename(self.filepath))[0]

        try:
            obj = create_optimized_mesh(
                obj_name,
                self.filepath,
                self.maintain_aspect,
                self.alpha_threshold,
                self.simplify_tolerance
            )

            if obj:
                # Apply texture
                apply_image_texture(obj, self.filepath)

                # Select the new object
                bpy.ops.object.select_all(action='DESELECT')
                obj.select_set(True)
                context.view_layer.objects.active = obj

                self.report({'INFO'}, f"Created mesh: {obj.name}")
                return {'FINISHED'}
            else:
                self.report({'ERROR'}, "Failed to create mesh")
                return {'CANCELLED'}

        except Exception as e:
            self.report({'ERROR'}, f"Error: {str(e)}")
            return {'CANCELLED'}

    def draw(self, context):
        """Draw the operator properties in the file browser."""
        layout = self.layout

        layout.prop(self, "alpha_threshold")
        layout.prop(self, "simplify_tolerance")
        layout.prop(self, "maintain_aspect")

    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}


class TEXCUT_PT_panel(bpy.types.Panel):
    """TexCut panel in the 3D viewport sidebar"""
    bl_label = "TexCut"
    bl_idname = "TEXCUT_PT_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'TexCut'

    def draw(self, context):
        layout = self.layout

        layout.label(text="Create Optimized Mesh:")
        layout.operator("texcut.create_mesh", icon='IMAGE_DATA')

        layout.separator()
        layout.label(text="Reduces pixel overdraw by")
        layout.label(text="following transparency outline")


# Registration
classes = (
    TEXCUT_OT_create_mesh,
    TEXCUT_PT_panel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()
